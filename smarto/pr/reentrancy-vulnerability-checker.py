#Reentrancy Vulnerability Checker

from dataclasses import dataclass, field
from typing import List, Set

@dataclass
class Operation:
    name: str
    # Additional attributes can be added as needed

@dataclass
class Function:
    name: str
    visibility: str  # e.g., 'public', 'external', 'internal', 'private'
    operations: List[Operation] = field(default_factory=list)
    modifiers: List[str] = field(default_factory=list)  # e.g., 'nonReentrant'

def find_potential_reentrancy_vulnerabilities(functions: List[Function]) -> List[str]:
    """
    Analyzes a list of functions to detect potential reentrancy vulnerabilities.
    
    Args:
        functions (List[Function]): The list of functions extracted from the contract.
    
    Returns:
        List[str]: A list of warnings or findings indicating potential vulnerabilities.
    """
    findings = []
    external_functions = [func for func in functions if func.visibility in ['external', 'public']]
    
    # Method 1: Detect CALL operations followed by state-changing operations without guards
    for func in external_functions:
        call_found = False
        for op in func.operations:
            if op.name == 'CALL':
                call_found = True
            elif call_found:
                if op.name in ['SSTORE', 'SLOAD', 'CREATE', 'DELEGATECALL', 'CALLCODE', 'SELFDESTRUCT']:
                    findings.append(f"Potential Reentrancy: Function '{func.name}' performs a CALL followed by a state-changing operation '{op.name}'.")
                    call_found = False  # Reset for next potential pattern
                elif op.name == 'REENTRANCY_GUARD':
                    # If a reentrancy guard is present after CALL, it's safer
                    findings.append(f"Reentrancy Guard Found: Function '{func.name}' has a reentrancy guard after CALL.")
                    call_found = False
                else:
                    # Other operations; continue checking
                    continue
    
    # Method 2: Check for absence of reentrancy guards in functions that perform external calls
    for func in external_functions:
        has_call = any(op.name == 'CALL' for op in func.operations)
        has_guard = any(modifier == 'nonReentrant' for modifier in func.modifiers)
        if has_call and not has_guard:
            findings.append(f"Missing Reentrancy Guard: Function '{func.name}' performs external calls but does not have a reentrancy guard.")
    
    # Method 3: Detect multiple external calls without intermediate state changes
    for func in external_functions:
        call_count = 0
        for op in func.operations:
            if op.name == 'CALL':
                call_count += 1
                if call_count > 1:
                    findings.append(f"Multiple External Calls: Function '{func.name}' performs multiple external calls without intermediate state changes.")
            elif op.name in ['SSTORE', 'SLOAD']:
                call_count = 0  # Reset count after state change
    
    # Method 4: Check for external calls in loops
    for func in external_functions:
        in_loop = False
        for op in func.operations:
            if op.name in ['FOR', 'WHILE', 'LOOP']:
                in_loop = True
            elif op.name == 'CALL' and in_loop:
                findings.append(f"External Call in Loop: Function '{func.name}' performs an external call inside a loop, which may lead to reentrancy vulnerabilities.")
    
    return findings

def main():
    # Example list of functions extracted from bytecode
    functions = [
        Function(
            name='transfer',
            visibility='external',
            operations=[
                Operation(name='CALL'),
                Operation(name='SSTORE')
            ],
            modifiers=[]
        ),
        Function(
            name='deposit',
            visibility='public',
            operations=[
                Operation(name='CALL'),
                Operation(name='REENTRANCY_GUARD'),
                Operation(name='SSTORE')
            ],
            modifiers=['nonReentrant']
        ),
        Function(
            name='withdraw',
            visibility='external',
            operations=[
                Operation(name='CALL'),
                Operation(name='CALL'),
                Operation(name='SSTORE')
            ],
            modifiers=[]
        ),
        Function(
            name='safeFunction',
            visibility='public',
            operations=[
                Operation(name='CALL'),
                Operation(name='REENTRANCY_GUARD'),
                Operation(name='SSTORE')
            ],
            modifiers=['nonReentrant']
        ),
        Function(
            name='loopFunction',
            visibility='external',
            operations=[
                Operation(name='FOR'),
                Operation(name='CALL'),
                Operation(name='SSTORE')
            ],
            modifiers=[]
        )
    ]
    
    findings = find_potential_reentrancy_vulnerabilities(functions)
    
    if findings:
        print("Potential Reentrancy Vulnerabilities Detected:")
        for finding in findings:
            print(f" - {finding}")
    else:
        print("No potential reentrancy vulnerabilities detected.")

if __name__ == "__main__":
    main()